<!-- Session 1: Implementation of Simple Algorithms -->

## Problems for Implementations

## Q1. Implement Euclid‚Äôs algorithm to find GCD (15265, 15) and calculate the number of times mod and assignment operations will be required.

    <!-- Euclid's Algorithm Implementation -->

    def gcd(a, b):
        mod_count = 0
        assignment_count = 0

        while b != 0:
            mod_count += 1  # Counting the modulo operation
            a, b = b, a % b
            assignment_count += 2  # Counting the two assignments

        return a, mod_count, assignment_count

        # Example usage
        a, b = 15265, 15
        gcd_value, mod_operations, assignment_operations = gcd(a, b)

        print(f"GCD of {a} and {b} is: {gcd_value}")
        print(f"Number of modulo operations: {mod_operations}")
        print(f"Number of assignment operations: {assignment_operations}")


## Q2(i). Implement Horner‚Äôs rule for evaluating polynomial P(x)= 6ùë•^6 + 5ùë•^5 + 4ùë•^4 - 3ùë•^3 + 2ùë•^2 + 8ùë• ‚àí 7 at x = 3. Calculate how many times (i) multiplications and addition operations will take (ii) how many times the loop will iterate

    <!-- Horner's Rule Implementation -->
    def horner(coefficients, x):
        multiplications = 0
        additions = 0
        result = 0

        for coeff in coefficients:
            result = result * x + coeff
            multiplications += 1  # One multiplication per iteration
            additions += 1  # One addition per iteration

        # Subtract one multiplication and addition as they are not needed in the first iteration
        multiplications -= 1
        additions -= 1

        return result, multiplications, additions

    # Polynomial coefficients for P(x) = 6x^6 + 5x^5 + 4x^4 - 3x^3 + 2x^2 + 8x - 7
    coefficients = [6, 5, 4, -3, 2, 8, -7]
    x = 3

    # Evaluate polynomial using Horner's rule
    result, multiplications, additions = horner(coefficients, x)

    # Print results
    print(f"Value of P(x) at x = {x}: {result}")
    print(f"Number of multiplications: {multiplications}")
    print(f"Number of additions: {additions}")
    print(f"Number of loop iterations: {len(coefficients)}")

## Q2(ii) Apply a brute force method to implement the above polynomial expression(Q2(i)) and compare it with Horner‚Äôs method in terms of number of multiplication operations

    # Brute force method to evaluate polynomial

    def brute_force_polynomial(coefficients, x):
        multiplications = 0
        result = 0
        degree = len(coefficients) - 1

        for i, coeff in enumerate(coefficients):
            term = coeff * (x ** (degree - i))
            multiplications += degree - i  # Count the multiplications for x^(degree - i)
            result += term

        return result, multiplications

    # Evaluate polynomial using brute force method
    brute_force_result, brute_force_multiplications = brute_force_polynomial(coefficients, x)

    # Print results for brute force method
    print(f"Value of P(x) at x = {x} using brute force: {brute_force_result}")
    print(f"Number of multiplications using brute force: {brute_force_multiplications}")

    # Compare with Horner's method
    print(f"Comparison:")
    print(f"Horner's method multiplications: {multiplications}")
    print(f"Brute force method multiplications: {brute_force_multiplications}")

## Q3.Implement multiplication of two matrices A[4,4] and B[4,4] and calculate (i) how many times the innermost and the outermost loops will run (ii) total number of multiplications and additions in computing the multiplication.

    # Matrix multiplication implementation

    def matrix_multiplication(A, B):
        n = len(A)  # Assuming square matrices of size n x n
        C = [[0 for _ in range(n)] for _ in range(n)]

        multiplications = 0
        additions = 0

        for i in range(n):  # Outer loop
            for j in range(n):  # Middle loop
                for k in range(n):  # Inner loop
                    C[i][j] += A[i][k] * B[k][j]
                    multiplications += 1  # One multiplication per iteration
                    if k > 0:
                        additions += 1  # One addition per iteration after the first

        return C, multiplications, additions

    # Example matrices A and B (4x4)
    A = [
        [1, 2, 3, 4],
        [5, 6, 7, 8],
        [9, 10, 11, 12],
        [13, 14, 15, 16]
    ]

    B = [
        [16, 15, 14, 13],
        [12, 11, 10, 9],
        [8, 7, 6, 5],
        [4, 3, 2, 1]
    ]

    # Perform matrix multiplication
    result, multiplications, additions = matrix_multiplication(A, B)

    # Print the resulting matrix
    print("Resultant Matrix C:")
    for row in result:
        print(row)

    # Print the number of operations
    print(f"Number of multiplications: {multiplications}")
    print(f"Number of additions: {additions}")

    # Calculate loop iterations
    outer_loops = len(A)
    inner_loops = len(A) * len(A)
    print(f"Number of outer loop iterations: {outer_loops}")
    print(f"Number of inner loop iterations: {inner_loops}")

## Q4. Implement left to right and right to left binary exponentiation methods for the following problems:

    (i) 4^512 (ii) 3^31

## Calculate the followings for problems (i) and (ii)
    ÔÇ∑ How many times the loops will be executed?
    ÔÇ∑ How many times the multiplication and additions operations will be executed?

## Q5. Implement Bubble Sort algorithm for the following list of numbers:

                    55 25 15 40 60 35 17 65 75 10

    Calculate (i) a number of exchange operations (ii) a number of times
    comparison operations (iii) a number of times the inner and outer loops will
    iterate?

## Q6. Implement Selection Sort algorithm on a similar set of data as in Q5 and (i)perform similar operations on the above example (ii) make a comparison between the two algorithms in terms of best case and worst case complexities
