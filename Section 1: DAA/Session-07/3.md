// Q3. Analyze the performance of both the algorithms on different problem instances and write a brief report.

## Performance Analysis Report: Prim's vs Kruskal's Algorithms for MCST
## Overview
    This report compares the performance of Prim’s and Kruskal’s algorithms for finding the Minimum Cost Spanning Tree (MCST) on the graph from Q1/Q2 (( V = 7, E = 9 )) and other problem instances. Both algorithms produced the same MCST (total cost = -1) on the given graph, handling negative weights effectively.

## Theoretical Complexity
    Prim’s Algorithm:
        Simple: ( O(V^2) ), best for dense graphs.
        Priority Queue: ( O(E \log V) ), efficient for sparse graphs.

    Kruskal’s Algorithm:
        ( O(E \log E) ), dominated by edge sorting.
        Union-Find operations are near-constant with path compression and union by rank.

## Performance on Given Graph (( V = 7, E = 9 ))
        Prim’s (Simple): ( O(V^2) = 49 ) operations.
        Kruskal’s: ( O(E \log E) \approx 28.5 ) (sorting) + 9 (Union-Find) = 37.5 operations.
    Observation: Kruskal’s is slightly faster due to the small number of edges and efficient sorting.

## Performance on Other Instances
    Sparse Graph (( V = 1000, E = 2000 )):
        Prim’s (Simple): ( 1,000,000 ).
        Prim’s (PQ): ( 20,000 ).
        Kruskal’s: ( 22,000 ).
        Winner: Prim’s with priority queue, as ( E \log V < E \log E ).

    Dense Graph (( V = 1000, E = 499,500 )):
        Prim’s (Simple): ( 1,000,000 ).
        Prim’s (PQ): ( 4,995,000 ).
        Kruskal’s: ( 9,490,500 ).
        Winner: Simple Prim’s, as ( V^2 < E \log V ).


    Negative Weights: No impact on runtime; both algorithms handle them seamlessly.

## Practical Considerations
    Memory:
        Prim’s: ( O(V) ), efficient for dense graphs with adjacency matrix.
        Kruskal’s: ( O(E) ), better for sparse graphs but costly in dense graphs.

    Implementation:
        Prim’s is simpler in its basic form.
        Kruskal’s requires sorting and Union-Find, adding complexity but scaling well.

## Recommendations
    Sparse Graphs: Use Prim’s with a priority queue (( O(E \log V) )).
    Dense Graphs: Use simple Prim’s (( O(V^2) )) if memory isn’t a constraint.
    General Use: Kruskal’s is often preferred for sparse graphs with an edge list representation, especially if the graph is already in edge-list form.
    Negative Weights: Both algorithms handle them correctly, with no performance impact.

## Conclusion
For the given graph, Kruskal’s was slightly faster due to its small size and sparsity. However, the choice of algorithm depends on graph density and representation. Prim’s excels in dense graphs with its simple implementation, while Kruskal’s and optimized Prim’s are better for sparse graphs.
